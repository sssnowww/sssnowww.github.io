import{_ as a,c as t,o as l,N as i}from"./chunks/framework.1e6a71f2.js";const e="/tcp_1.png",r="/udp_tcp_1.png",o="/udp_tcp_2.png",h="/url.png",b=JSON.parse('{"title":"计算机网络","description":"","frontmatter":{},"headers":[],"relativePath":"articles/计算机网络.md"}'),T={name:"articles/计算机网络.md"},n=i('<h1 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h1><h2 id="http-建立流程" tabindex="-1">HTTP 建立流程 <a class="header-anchor" href="#http-建立流程" aria-label="Permalink to &quot;HTTP 建立流程&quot;">​</a></h2><p>第1步：TCP通过三次握手建立双方连接；<br> 第2步：客户端通过发送请求报文及请求数据给服务端；<br> 第3步：服务端返回响应报文及响应数据给客户端；<br> 第4步：TCP通过四次挥手进行断开连接。</p><h2 id="tcp连接-三次握手" tabindex="-1">TCP连接（三次握手） <a class="header-anchor" href="#tcp连接-三次握手" aria-label="Permalink to &quot;TCP连接（三次握手）&quot;">​</a></h2><p>第1次握手：客户端通过标志位发送SYN = j给服务端，表明客户端想要建立连接，并进入SYN_SEND状态，等待服务器确认。</p><p>第2次握手：服务端收到SYN标志后返回ACK = (j+1)应答标志给客户端，同时自己也发送一个SYN包（syn=k），表明可以建立连接，此时服务器进入SYN_RECV状态。</p><p>第3次握手：客户端收到服务端SYN+ACK应答标志后回传ACK=(k+1)标志给服务端，说明自己已经收到了ACK标志，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 <img src="'+e+'" alt="An image"></p><h2 id="tcp和udp的区别" tabindex="-1">TCP和UDP的区别 <a class="header-anchor" href="#tcp和udp的区别" aria-label="Permalink to &quot;TCP和UDP的区别&quot;">​</a></h2><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h3><p>UDP：用户数据包协议，是一个简单的面向数据报的通信协议。</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h3><p>TCP：传输控制协议，是一种可靠、面向字节流的通信协议。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>UDP与TCP都位于传输层。 <img src="'+r+'" alt="An image"> 两者区别如下表所示： <img src="'+o+'" alt="An image"></p><h2 id="http1-0-1-1-2-0的区别" tabindex="-1">HTTP1.0/1.1/2.0的区别 <a class="header-anchor" href="#http1-0-1-1-2-0的区别" aria-label="Permalink to &quot;HTTP1.0/1.1/2.0的区别&quot;">​</a></h2><h3 id="http1-0" tabindex="-1">HTTP1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;HTTP1.0&quot;">​</a></h3><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接。</li></ul><h3 id="http1-1" tabindex="-1">HTTP1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;HTTP1.1&quot;">​</a></h3><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><h3 id="http2-0" tabindex="-1">HTTP2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;HTTP2.0&quot;">​</a></h3><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="http和https的区别" tabindex="-1">HTTP和HTTPS的区别 <a class="header-anchor" href="#http和https的区别" aria-label="Permalink to &quot;HTTP和HTTPS的区别&quot;">​</a></h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li><li>HTTP和HTTPS使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS由于需要设计加密以及多次握手，性能方面不如HTTP</li><li>HTTPS需要SSL，SSL证书需要钱，功能越强大的证书费用越高</li></ul><h2 id="地址栏输入-url-敲下回车后发生了什么" tabindex="-1">地址栏输入 URL 敲下回车后发生了什么? <a class="header-anchor" href="#地址栏输入-url-敲下回车后发生了什么" aria-label="Permalink to &quot;地址栏输入 URL 敲下回车后发生了什么?&quot;">​</a></h2><ul><li>URL解析</li><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>响应请求</li><li>页面渲染</li></ul><p><strong>页面渲染的过程：</strong></p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上 <img src="'+h+'" alt="An image"></li></ul>',27),s=[n];function p(P,c,d,u,_,S){return l(),t("div",null,s)}const H=a(T,[["render",p]]);export{b as __pageData,H as default};
