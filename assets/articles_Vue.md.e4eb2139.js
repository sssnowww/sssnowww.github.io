import{_ as e,c as i,o as a,N as l}from"./chunks/framework.1e6a71f2.js";const t="/shengmingzhouqi.png",r="/zujiantongxin.png",b=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Vue.md"}'),o={name:"articles/Vue.md"},u=l('<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="vue核心特性" tabindex="-1">Vue核心特性 <a class="header-anchor" href="#vue核心特性" aria-label="Permalink to &quot;Vue核心特性&quot;">​</a></h2><h3 id="数据驱动-mvvm" tabindex="-1">数据驱动（MVVM） <a class="header-anchor" href="#数据驱动-mvvm" aria-label="Permalink to &quot;数据驱动（MVVM）&quot;">​</a></h3><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li></ul><h3 id="组件化" tabindex="-1">组件化 <a class="header-anchor" href="#组件化" aria-label="Permalink to &quot;组件化&quot;">​</a></h3><ul><li>降低整个系统的耦合度</li><li>调试方便</li><li>提高可维护性</li></ul><h3 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h3><p>常用指令：</p><ul><li>条件渲染指令v-if</li><li>列表渲染指令v-for</li><li>属性绑定指令v-bind</li><li>事件绑定指令v-on</li><li>双向数据绑定指令v-model</li></ul><h2 id="vue和react对比" tabindex="-1">Vue和React对比 <a class="header-anchor" href="#vue和react对比" aria-label="Permalink to &quot;Vue和React对比&quot;">​</a></h2><h3 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：Vue的weex、React的React native</li><li>都有自己的构建工具：Vue的vue-cli、React的Create React App</li></ul><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据</li><li>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</li></ul><h2 id="v-if和v-show" tabindex="-1">v-if和v-show <a class="header-anchor" href="#v-if和v-show" aria-label="Permalink to &quot;v-if和v-show&quot;">​</a></h2><h3 id="相同点-1" tabindex="-1">相同点 <a class="header-anchor" href="#相同点-1" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ul><li>都能控制DOM元素在页面的显示</li></ul><h3 id="区别-1" tabindex="-1">区别 <a class="header-anchor" href="#区别-1" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>v-if是动态添加，当值为false时，是完全移除该元素，即DOM树中不存在该元素</li><li>v-show仅是隐藏/显示，值为false时，该元素依旧存在于DOM树中</li><li>v-if比v-show开销更大（直接操作DOM节点增加与删除）</li><li>如果需要非常频繁地切换，则使用 v-show 较好</li><li>如果在运行时条件很少改变，则使用 v-if 较好</li></ul><h2 id="vue实例挂载的过程" tabindex="-1">Vue实例挂载的过程 <a class="header-anchor" href="#vue实例挂载的过程" aria-label="Permalink to &quot;Vue实例挂载的过程&quot;">​</a></h2><ul><li>new Vue的时候调用会调用_init方法 <ul><li>定义 $set、$get 、$delete、$watch 等方法</li><li>定义 $on、$off、$emit、$off等事件</li><li>定义 _update、$forceUpdate、$destroy生命周期</li></ul></li><li>调用$mount进行页面的挂载</li><li>挂载的时候主要是通过mountComponent方法</li><li>定义updateComponent更新函数</li><li>执行render生成虚拟DOM</li><li>_update将虚拟DOM生成真实DOM结构，并且渲染到页面中</li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p><img src="'+t+'" alt="An image"></p><h2 id="组件间通信" tabindex="-1">组件间通信 <a class="header-anchor" href="#组件间通信" aria-label="Permalink to &quot;组件间通信&quot;">​</a></h2><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h3><p><img src="'+r+'" alt="An image"></p><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><h4 id="props传递数据" tabindex="-1">props传递数据 <a class="header-anchor" href="#props传递数据" aria-label="Permalink to &quot;props传递数据&quot;">​</a></h4><ul><li>适用场景：父组件传递数据给子组件</li><li>子组件设置props属性，定义接收父组件传递过来的参数</li><li>父组件在使用子组件标签中通过字面量来传递值</li></ul><h4 id="emit触发自定义事件" tabindex="-1">$emit触发自定义事件 <a class="header-anchor" href="#emit触发自定义事件" aria-label="Permalink to &quot;$emit触发自定义事件&quot;">​</a></h4><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul><h4 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref&quot;">​</a></h4><ul><li>父组件在使用子组件的时候设置ref</li><li>父组件通过设置子组件ref来获取数据</li></ul><h4 id="eventbus" tabindex="-1">EventBus <a class="header-anchor" href="#eventbus" aria-label="Permalink to &quot;EventBus&quot;">​</a></h4><ul><li>使用场景：兄弟组件传值</li><li>创建一个中央事件总线EventBus</li><li>兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>另一个兄弟组件通过$on监听自定义事件</li></ul><h2 id="mixin" tabindex="-1">mixin <a class="header-anchor" href="#mixin" aria-label="Permalink to &quot;mixin&quot;">​</a></h2><ul><li>替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数</li><li>合并型策略是data, 通过set方法进行合并和重新赋值</li><li>队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行</li><li>叠加型有component、directives、filters，通过原型链进行层层的叠加</li></ul><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p>它是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。<br> 在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性。<br> 创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应。</p><h3 id="为什么要用虚拟dom" tabindex="-1">为什么要用虚拟DOM <a class="header-anchor" href="#为什么要用虚拟dom" aria-label="Permalink to &quot;为什么要用虚拟DOM&quot;">​</a></h3><p>操作DOM的代价是昂贵的，频繁操作会出现页面卡顿，影响用户的体验。</p><h3 id="如何实现虚拟dom" tabindex="-1">如何实现虚拟DOM <a class="header-anchor" href="#如何实现虚拟dom" aria-label="Permalink to &quot;如何实现虚拟DOM&quot;">​</a></h3><p>createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构。</p><h2 id="vue3-0" tabindex="-1">Vue3.0 <a class="header-anchor" href="#vue3-0" aria-label="Permalink to &quot;Vue3.0&quot;">​</a></h2><h3 id="vue3-0与vue2-0的区别" tabindex="-1">Vue3.0与Vue2.0的区别 <a class="header-anchor" href="#vue3-0与vue2-0的区别" aria-label="Permalink to &quot;Vue3.0与Vue2.0的区别&quot;">​</a></h3><ul><li>双向数据绑定原理不同 <ul><li>vue2-ES5的一个api-Object.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。</li><li>vue3-ES6的Proxy api对数据代理，优势：1、defineProperty只能监听某个属性，不能对全对象监听；2、可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)；3、可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化。</li></ul></li><li>是否支持碎片（vue3支持，就是说可以拥有多个根节点）</li><li>API类型不同 <ul><li>vue2-选项类型api在代码里分割了不同的属性</li><li>vue3-合成型api能让我们使用方法来分割</li></ul></li><li>定义数据变量和方法不同 <ul><li>vue2-数据变量：data(){}，方法：methods:{}；</li><li>vue3-使用一个新的setup()方法，此方法在组件初始化构造的时候触发，使用以下三个步骤建立反应性数据：1、从vue引入reactive；2、使用reactive（）方法来声明数据为响应型数据；3、使用setup()方法来返回响应性数据，从而template可以获取这些响应型数据</li></ul></li><li>生命周期钩子函数不同<br> vue2：</li><li>beforeCreate 组件创建之前</li><li>created 组件创建之后</li><li>beforeMount 组价挂载到页面之前执行</li><li>mounted 组件挂载到页面之后执行</li><li>beforeUpdate 组件更新之前</li><li>updated 组件更新之后<br> vue3：</li><li>setup 开始创建组件</li><li>onBeforeMount 组价挂载到页面之前执行</li><li>onMounted 组件挂载到页面之后执行</li><li>onBeforeUpdate 组件更新之前</li><li>onUpdated 组件更新之后</li><li>父子传参不同</li><li>vue2：父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象。</li><li>vue3：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。</li><li>指令与插槽不同 <ul><li>vue2：使用pototype(原型)的形式去进行操作，引入的是构造函数。</li><li>vue3：使用结构的形式进行操作，引入的是工厂函数；vue3中app组件中可以没有根标签。</li></ul></li><li>main.js文件不同</li></ul>',47),n=[u];function h(d,s,c,m,p,v){return a(),i("div",null,n)}const q=e(o,[["render",h]]);export{b as __pageData,q as default};
