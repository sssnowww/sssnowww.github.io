import{_ as l,o as a,c as i,S as t}from"./chunks/framework.ad333ad2.js";const e="/osi.png",o="/tcp_ip_1.png",n="/tcp_ip_2.png",s="/tcp_1.png",r="/tcp_2.png",p="/udp_tcp_1.png",T="/udp_tcp_2.png",h="/udp_tcp_3.png",c="/zhuangtaima.png",P="/http_qingqiu.png",u="/dns_fuzaijunheng.png",d="/url.png",E=JSON.parse('{"title":"计算机网络","description":"","frontmatter":{"tag":["基础"]},"headers":[],"relativePath":"articles/计算机网络.md","lastUpdated":1681047375000}'),m={name:"articles/计算机网络.md"},C=t('<h1 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h1><h2 id="http-建立流程" tabindex="-1">HTTP 建立流程 <a class="header-anchor" href="#http-建立流程" aria-label="Permalink to &quot;HTTP 建立流程&quot;">​</a></h2><p>第1步：TCP通过三次握手建立双方连接；<br> 第2步：客户端通过发送请求报文及请求数据给服务端；<br> 第3步：服务端返回响应报文及响应数据给客户端；<br> 第4步：TCP通过四次挥手进行断开连接。</p><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><p><img src="'+e+'" alt="An image"></p><h2 id="tcp-ip协议" tabindex="-1">TCP/IP协议 <a class="header-anchor" href="#tcp-ip协议" aria-label="Permalink to &quot;TCP/IP协议&quot;">​</a></h2><p><img src="'+o+'" alt="An image"><img src="'+n+'" alt="An image"></p><ul><li>应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li><li>传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：传输控制协议 (Transmission Control Protocol，TCP)-提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；用户数据报协议 (User Datagram Protocol，UDP)-提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li><li>网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li><li>数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li><li>物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li></ul><h2 id="tcp连接" tabindex="-1">TCP连接 <a class="header-anchor" href="#tcp连接" aria-label="Permalink to &quot;TCP连接&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><ul><li>第1次握手：客户端通过标志位发送SYN = j给服务端，表明客户端想要建立连接，并进入SYN_SEND状态，等待服务器确认。</li><li>第2次握手：服务端收到SYN标志后返回ACK = (j+1)应答标志给客户端，同时自己也发送一个SYN包（syn=k），表明可以建立连接，此时服务器进入SYN_RECV状态。</li><li>第3次握手：客户端收到服务端SYN+ACK应答标志后回传ACK=(k+1)标志给服务端，说明自己已经收到了ACK标志，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 <img src="'+s+'" alt="An image"></li></ul><p>为什么不是两次握手？</p><ul><li>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</li><li>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</li></ul><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><ul><li>第1次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第2次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li><li>第3次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li><li>第4次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ul><p>其他解释：</p><ul><li>第一次挥手：客户端发送报文，其中有一个参数代表告诉服务器，想要释放连接</li><li>第二次挥手：服务器接收报文后，返回响应告诉客户端，收到想要释放连接指令，但是现在还有数据没处理完，等下次通知才能关闭</li><li>第三次挥手：服务器发送报文告诉客户端，可以释放连接</li><li>第四次挥手：客户端发送报文，表示收到，服务器接收到之后就会释放连接 <img src="'+r+'" alt="An image"></li></ul><p>四次挥手原因？</p><ul><li>服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手</li></ul><p>TCP如何保证数据传输的可靠性？（重传机制）</p><ul><li>利用ACK信号，ACK信号是发送方按照顺序给要发送的数据包的每个字节都添加上一个编号，接收方收到发送方的数据包之后返回一个ACK信号表示下一个需求的数据包的初始字节标号。</li><li>在等待接收方回传ACK信号超时之后，发送方会重新发送数据包，一旦开始重传，下次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号的话就就会强制终止连接。</li></ul><p>TCP阻塞控制算法？</p><ul><li><ol><li>慢启动（指数增长）：开始传输时，发送的数据大小从小到大逐渐增大到阻塞窗口的数值</li></ol></li><li><ol start="2"><li>阻塞避免（线性增长）：有一个cwnd和一个ssthresh慢启动阈值，当cwnd大于慢启动阈值的时候，阻塞窗口使用慢启动，否则是使用阻塞避免算法</li></ol></li><li><ol start="3"><li>快重传：数据传输的时候数据被分成报文，每个报文都有自己的序号，中间的一部分丢失接收方没收到，接收方连续收到后面的数据，则发回对丢失前数据的重复却，让发送方指定数据丢了，重新传送</li></ol></li><li><ol start="4"><li>快恢复：跟快重传配合，数据丢失的时候，发送方收到接收方返回的三个重复确认信息的时候，把每次传输的数据量减少为原来的一半，阻塞窗口也改为这个值，然后重新开始用阻塞避免算法</li></ol></li></ul><h2 id="tcp和udp的区别" tabindex="-1">TCP和UDP的区别 <a class="header-anchor" href="#tcp和udp的区别" aria-label="Permalink to &quot;TCP和UDP的区别&quot;">​</a></h2><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h3><p>UDP：用户数据包协议，是一个简单的面向数据报的通信协议。</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h3><p>TCP：传输控制协议，是一种可靠、面向字节流的通信协议。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>UDP与TCP都位于传输层。 <img src="'+p+'" alt="An image"> 两者区别如下表所示： <img src="'+T+'" alt="An image"></p><ul><li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li><li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li><li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li><li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p><img src="'+h+'" alt="An image"></p><ul><li>TCP：效率要求相对低，但是对准确性要求相对高的场景，例如文件传输，接收邮件，远程登录</li><li>UDP：效率要求相对高，对准确性要求相对低的场景，例如QQ聊天，在线视频，网络电话等</li></ul><h2 id="http1-0-1-1-2-0的区别" tabindex="-1">HTTP1.0/1.1/2.0的区别 <a class="header-anchor" href="#http1-0-1-1-2-0的区别" aria-label="Permalink to &quot;HTTP1.0/1.1/2.0的区别&quot;">​</a></h2><h3 id="http1-0" tabindex="-1">HTTP1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;HTTP1.0&quot;">​</a></h3><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接。</li></ul><h3 id="http1-1" tabindex="-1">HTTP1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;HTTP1.1&quot;">​</a></h3><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><h3 id="http2-0" tabindex="-1">HTTP2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;HTTP2.0&quot;">​</a></h3><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><p>注：<strong>为什么HTTP1.1不能实现多路复用？</strong></p><p>因为：HTTP1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。</p><h2 id="http和https的区别" tabindex="-1">HTTP和HTTPS的区别 <a class="header-anchor" href="#http和https的区别" aria-label="Permalink to &quot;HTTP和HTTPS的区别&quot;">​</a></h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li><li>HTTP和HTTPS使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS由于需要设计加密以及多次握手，性能方面不如HTTP</li><li>HTTPS需要SSL，SSL证书需要钱，功能越强大的证书费用越高</li></ul><p>HTTPS工作步骤：</p><ol><li>客户端向服务器发送请求，建立连接</li><li>服务端收到请求后，把包含公钥的证书响应给客户端</li><li>客户端开始与服务端协商加密等级，确定加密等级之后建立会话密钥，客户端会通过网站的公钥加密会话密钥，然后发送给服务端</li><li>服务端通过自己的私钥解密会话密钥</li><li>之后服务器通过会话密钥加密与客户端进行通信</li></ol><h2 id="http状态码的含义" tabindex="-1">HTTP状态码的含义 <a class="header-anchor" href="#http状态码的含义" aria-label="Permalink to &quot;HTTP状态码的含义&quot;">​</a></h2><p><img src="'+c+'" alt="An image"></p><ul><li>304 表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>301 永久性重定向，表示资源已被分配了新的 URL</li><li>401 表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 表示对请求资源的访问被服务器拒绝</li></ul><h2 id="http请求" tabindex="-1">HTTP请求 <a class="header-anchor" href="#http请求" aria-label="Permalink to &quot;HTTP请求&quot;">​</a></h2><ul><li>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</li><li>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 <img src="'+P+`" alt="An image"></li></ul><h2 id="get和post区别" tabindex="-1">GET和POST区别 <a class="header-anchor" href="#get和post区别" aria-label="Permalink to &quot;GET和POST区别&quot;">​</a></h2><h3 id="get" tabindex="-1">GET <a class="header-anchor" href="#get" aria-label="Permalink to &quot;GET&quot;">​</a></h3><p>GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。</p><h3 id="post" tabindex="-1">POST <a class="header-anchor" href="#post" aria-label="Permalink to &quot;POST&quot;">​</a></h3><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。</p><h3 id="区别-1" tabindex="-1">区别 <a class="header-anchor" href="#区别-1" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>本质上都是TCP链接，并无差别，但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别。</p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p>其他解释：</p><ul><li>GET - 从指定的资源请求数据。</li><li>POST - 向指定的资源提交要被处理的数据。</li><li>GET：不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内。</li><li>GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。</li><li>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</li><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200ok（返回数据）。</li></ul><p><strong>参数位置</strong></p><ul><li>不携带参数时，最大区别为第一行方法名不同。</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST /uri HTTP/1.1 \\r\\n</span></span>
<span class="line"><span style="color:#A6ACCD;">GET /uri HTTP/1.1 \\r\\n</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>携带参数时，GET请求是放在url中，POST则放在body中</li></ul><p>GET</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: localhost</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>POST</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST /index.html HTTP/1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: localhost</span></span>
<span class="line"><span style="color:#A6ACCD;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#A6ACCD;">name=qiming.c&amp;age=22</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>参数长度</strong></p><p><strong>安全</strong></p><ul><li>POST比GET安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，只有使用HTTPS才能加密安全。</li></ul><p><strong>数据包</strong></p><ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）</li><li>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</li></ul><h2 id="地址栏输入-url-敲下回车后发生了什么" tabindex="-1">地址栏输入 URL 敲下回车后发生了什么? <a class="header-anchor" href="#地址栏输入-url-敲下回车后发生了什么" aria-label="Permalink to &quot;地址栏输入 URL 敲下回车后发生了什么?&quot;">​</a></h2><ul><li>URL解析</li><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>响应请求</li><li>页面渲染</li></ul><h3 id="url解析" tabindex="-1">URL解析 <a class="header-anchor" href="#url解析" aria-label="Permalink to &quot;URL解析&quot;">​</a></h3><ol><li>地址解析</li></ol><ul><li>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作</li></ul><ol start="2"><li>其他操作</li></ol><ul><li>目前大部分浏览器都会强制客户端使用HTTPS协议以保证信息传输的安全性，因此会进行安全检查，访问限制等操作</li></ul><ol start="3"><li>缓存检查</li></ol><ul><li>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求</li></ul><h3 id="dns解析" tabindex="-1">DNS解析 <a class="header-anchor" href="#dns解析" aria-label="Permalink to &quot;DNS解析&quot;">​</a></h3><p>DNS解析是寻找所需要的资源的IP地址的过程。因为互联网中每一台连网的机器都有唯一IP作为标识，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。</p><ol><li>查询缓存</li></ol><ul><li>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为DNS高速缓存。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询</li></ul><ol start="2"><li>递归解析</li></ol><ul><li>输入www.baidu.com网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去com顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。大致过程就是 .-&gt; .com -&gt;baidu.com. -&gt; www.baidu.com.</li></ul><ol start="3"><li>DNS负载均衡</li></ol><ul><li>访问baidu.com的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡 <img src="`+u+'" alt="An image"></li></ul><h3 id="页面渲染的过程" tabindex="-1">页面渲染的过程 <a class="header-anchor" href="#页面渲染的过程" aria-label="Permalink to &quot;页面渲染的过程&quot;">​</a></h3><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上 <img src="'+d+'" alt="An image"></li></ul><h2 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h2><ul><li>多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用</li><li>http 重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点：只有第一次有效果，后续操作维持在该服务器</li><li>dns 负载均衡：解析域名时，访问多个 ip 服务器中的一个（可监控性较弱），原因 - 避免 DOM 渲染的冲突</li><li>反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到服务器群的数量</li></ul><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;WebSocket&quot;">​</a></h2><h3 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h3><ul><li>WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议，它基于TCP传输协议，并复用HTTP的握手通道</li><li>websocket是一种网络通信协议，对比HTTP协议来说，HTTP协议是无状态，无连接单向的应用协议，而且只能从客户端发起，服务端对请求做出应答，因此无法实现服务器主动向客户端发送信息</li><li>WebSocket连接允许客户端和服务端进行全双工通信，而且只需要建立一次连接就可以一直保持连接状态</li></ul><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据</li><li>建立在TCP协议之上，服务端实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li></ul>',101),S=[C];function b(g,_,q,A,H,k){return a(),i("div",null,S)}const f=l(m,[["render",b]]);export{E as __pageData,f as default};
