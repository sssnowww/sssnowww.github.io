import{_ as s,o as a,c as l,R as n}from"./chunks/framework.ac544104.js";const o="/huancun_1.png",u=JSON.parse('{"title":"浏览器","description":"","frontmatter":{},"headers":[],"relativePath":"articles/浏览器.md","lastUpdated":1681047375000}'),e={name:"articles/浏览器.md"},p=n('<h1 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h1><h2 id="阻塞" tabindex="-1">阻塞 <a class="header-anchor" href="#阻塞" aria-label="Permalink to &quot;阻塞&quot;">​</a></h2><h2 id="重绘-repaint-和回流-reflow" tabindex="-1">重绘（Repaint）和回流（Reflow） <a class="header-anchor" href="#重绘-repaint-和回流-reflow" aria-label="Permalink to &quot;重绘（Repaint）和回流（Reflow）&quot;">​</a></h2><ul><li>回流：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中。</li><li>重绘：当对DOM的修改导致样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘。</li><li>回流必定会发生重绘，重绘不一定会引发回流！</li><li>如何减少回流、重绘？（减少回流、重绘就是减少对DOM的操作） <ul><li>直接改变className，如果动态改变样式，则使用cssText（减少设置多项内联样式）</li><li>让要操作的元素进行“离线处理”，处理完后一起更新</li><li>不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</li><li>让元素脱离动画流，减少render树的规模</li><li>牺牲平滑度换取速度</li><li>避免使用table布局</li><li>IE中避免使用javascript表达式</li></ul></li></ul><h2 id="前端缓存" tabindex="-1">前端缓存 <a class="header-anchor" href="#前端缓存" aria-label="Permalink to &quot;前端缓存&quot;">​</a></h2><p><img src="'+o+`" alt="An image"></p><h2 id="http缓存" tabindex="-1">HTTP缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;HTTP缓存&quot;">​</a></h2><p>优先级较高的是强缓存，当强缓存失效的情况下，才会走协商缓存流程。都是通过设置HTTP Header来实现的。</p><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h3><p>特点：</p><ul><li>1.不会向服务器发送网络请求，直接从缓存中读取资源</li><li>2.请求返回200的状态码</li><li>3.在devtools的network选项卡可以看到size显示from disk cache或from memory cache</li></ul><p>设置方法：</p><ul><li>通过两种HTTP Header实现：Expires、Cache-Control</li></ul><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><ul><li>协商缓存就是强缓存失效后，浏览器携带资源的缓存标识向服务器发起请求，由服务器根据缓存标识决定是否继续使用缓存的过程。</li><li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回304状态码，并且更新浏览器现有缓存有效期。</li><li>当资源失效时，返回200状态码和最新的资源。</li><li>协商缓存可以通过设置两种HTTP Header实现：Last-Modified、ETag。</li></ul><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h2><ul><li>定义：把一个已经请求过的web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中，缓存会根据进来的请求保存输出内容的副本</li><li>为什么使用缓存？-（1）减少网络带宽消耗；（2）降低服务器压力；（3）减少网络延迟，加快页面打开速度</li><li>浏览器端的缓存规则：新鲜度（过期机制）+校验值（验证机制）两个维度</li></ul><h2 id="sessionstorage和localstorage和cookie的区别" tabindex="-1">sessionstorage和localstorage和cookie的区别 <a class="header-anchor" href="#sessionstorage和localstorage和cookie的区别" aria-label="Permalink to &quot;sessionstorage和localstorage和cookie的区别&quot;">​</a></h2><p><strong>共同点</strong></p><p>三者都是浏览器的本地存储。</p><p><strong>区别</strong></p><ul><li>cookie是由服务器端写入的，而sessionstorage和localstorage都是由前端写入的</li><li>cookie的生命周期是由服务器端在写入时就设置好的，localstorage是写入就一直存在，除非手动清除，sessionstorage是页面关闭的时候就会自动清除。</li><li>cookie的存储空间比较小大概4KB，sessionstorage和localstorage存储空间比较大，大概5M</li><li>sessionstorage和localstorage和cookie数据共享都遵循同源原则，sessionstorage还限制必须是同一个页面</li></ul><h2 id="session和cookie" tabindex="-1">session和cookie <a class="header-anchor" href="#session和cookie" aria-label="Permalink to &quot;session和cookie&quot;">​</a></h2><h3 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h3><p>我们知道HTTP协议是无状态的，一次请求完成，不会持久化请求与相应的信息。那么，在购物车、用户登录状态、页面个性化设置等场景下，就无法识别特定用户的信息。这时Cookie就出现了。</p><p>Cookie是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送。对于Cookie，可以设置过期时间。</p><p>通常，Cookie用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。这样就解决了HTTP无状态的问题。</p><p>Cookie主要用于以下方面：</p><ul><li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li><li>个性化设置(如用户自定义设置、主题等)</li><li>浏览器行为跟踪(如跟踪分析用户行为等)</li><li>Cookie存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。针对这个问题，怎么解决呢?那就引入了Session。</li></ul><h3 id="session" tabindex="-1">session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;session&quot;">​</a></h3><p>Session代表服务器和客户端一次会话的过程。</p><p>维基百科这样解释道：在计算机科学领域来说，尤其是在网络领域，会话(session)是一种持久网络协议，在用户(或用户代理)端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议(例如telnet或FTP)中是非常重要的部分。</p><p>对照Cookie，Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>当在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而会在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。</p><p>目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li><li>存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。</li><li>有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li><li>隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。</li><li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li></ul><h3 id="禁用cookie会怎样" tabindex="-1">禁用cookie会怎样 <a class="header-anchor" href="#禁用cookie会怎样" aria-label="Permalink to &quot;禁用cookie会怎样&quot;">​</a></h3><ul><li>方案一：拼接SessionId参数。在GET或POST请求中拼接SessionID，GET请求通常通过URL后面拼接参数来实现，POST请求可以放在Body中。无论哪种形式都需要与服务器获取保持一致。这种方案比较常见，比如老外的网站，经常会提示是否开启Cookie。如果未点同意或授权，会发现浏览器的URL路径中往往有&quot;?sessionId=123abc&quot;这样的参数。</li><li>方案二：基于Token(令牌)。在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器，用于服务器验证请求用户的身份。</li></ul><h3 id="同源策略与跨域请求" tabindex="-1">同源策略与跨域请求 <a class="header-anchor" href="#同源策略与跨域请求" aria-label="Permalink to &quot;同源策略与跨域请求&quot;">​</a></h3><p>所谓的“同源”指的是“三个相同”：协议相同、域名相同、端口相同。只有这三个完全相同，才算是同源。</p><p>同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>比如，用户访问了银行网站A，再去浏览其他网站，如果其他网站可以读取A的Cookie，隐私信息便会泄露。更可怕的是，通常Cookie还用来保存用户登录状态，会出现冒充用户行为。因此，&quot;同源策略&quot;是必需的，如果Cookie可以共享，互联网就毫无安全可言了。</p><p>同源策略保证了一定的安全性，但在某些场景下也带来了不便，比如常见的跨域请求问题。</p><p>在HTML中，<code>&lt;a&gt;</code>,<code>&lt;form&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;link&gt;</code>等标签以及Ajax都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。同源即同域，三项有一项不同便会出现跨域请求。</p><p>浏览器会对跨域请求做出限制，因为跨域请求可能会被利用发动CSRF攻击。</p><p>CSRF（Cross-site request forgery），即“跨站请求伪造”，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p><p>针对跨域请求通常有如下方法：</p><ul><li>通过代理避开跨域请求</li><li>通过Jsonp跨域</li><li>通过跨域资源共享（CORS）</li></ul><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><p>跨域：当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说明该接口跨域了。<br> 跨域限制的原因：浏览器为了保证网页的安全，出的同源协议策略。<br> 跨域解决方案：</p><ul><li>cors：通过设置后端允许跨域实现</li><li>nodejs中间件、nginx反向代理</li><li>JSONP</li><li>document.domain + iframe跨域</li><li>postmessage：H5新增API，通过发送和接收API实现跨域通信</li><li>后端在头部信息里设置安全域名</li></ul><p>跨域场景：前后端分离式开发、调用第三方接口。</p><h2 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;JSONP&quot;">​</a></h2><p>JSONP核心原理：cript标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于GET请求。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> jsonp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">url</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">params</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">callbackName</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">generateUrl</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dataSrc</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">params</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">params</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#A6ACCD;">dataSrc</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">=</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">params[key]</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&amp;</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">dataSrc</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">callback=</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">callbackName</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#A6ACCD;">url</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">?</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">dataSrc</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">scriptEle</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">script</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">scriptEle</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">src</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">generateUrl</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">scriptEle</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">window</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">callbackName</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">scriptEle</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="浏览器内核线程" tabindex="-1">浏览器内核线程 <a class="header-anchor" href="#浏览器内核线程" aria-label="Permalink to &quot;浏览器内核线程&quot;">​</a></h2><ul><li>浏览器内核是指浏览器的渲染引擎，负责解析和渲染网页。</li><li>浏览器内核包括多个线程，每个线程负责相关工作，常见的线程有： <ul><li>GUI渲染线程：负责调用GPU进行界面渲染，包括解析HTML、CSS、构建DOM树、CSSOM、Layout、Layer等。</li><li>JS引擎线程：负责处理执行JavaScript脚本，这是JS的主线程，所以JS是单线程的编程语言。</li><li>事件触发线程：负责管理事件队列，当事件符合触发条件时，将事件添加到待处理队列（宏任务）的队尾，等待JS引擎的处理。</li><li>定时器触发线程：负责管理定时器（setTimeout、setInterval等），当定时器到期时，将定时器回调函数添加到待处理队列（宏任务）的队尾，等待JS引擎的处理。</li><li>异步http请求线程：负责发送异步请求（XMLHttpRequest等），当请求完成或失败时，将回调函数添加到待处理队列（宏任务或微任务）的队尾，等待JS引擎的处理。</li></ul></li></ul><h2 id="浏览器安全" tabindex="-1">浏览器安全 <a class="header-anchor" href="#浏览器安全" aria-label="Permalink to &quot;浏览器安全&quot;">​</a></h2><h3 id="xss跨站脚本攻击" tabindex="-1">XSS跨站脚本攻击 <a class="header-anchor" href="#xss跨站脚本攻击" aria-label="Permalink to &quot;XSS跨站脚本攻击&quot;">​</a></h3><p><strong>定义</strong></p><ul><li>XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等</li><li>XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行</li></ul><p>攻击者可以通过XSS攻击进行如下操作：</p><ul><li>获取页面数据，如DOM、cookie、localStorage</li><li>DOS攻击，发送合理请求，占用服务器资源，从而让用户无法访问服务器</li><li>破坏页面结构</li><li>流量劫持</li></ul><p><strong>攻击类型</strong></p><ul><li>存储型：指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行</li><li>反射型：指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成XSS攻击</li><li>DOM型：指的通过修改页面的DOM节点形成的XSS</li></ul><p><strong>防御</strong></p><ul><li>对一些敏感信息进行保护，比如cookie使用http-only，使得脚本无法获取，也可以使用验证码，避免脚本伪装成用户执行一些操作</li><li>建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击</li><li>替换特殊符号，如&lt; 变为<code>&amp;lt</code>; ，&gt;变为<code>&amp;gt</code>; ，这样script就会变成<code>&amp;lt;script&amp;gt</code>; ，直接显示，而不会作为脚本执行，并且前端需要替换，后端也需要替换，都做总不会出错</li></ul><h3 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-label="Permalink to &quot;CSRF攻击&quot;">​</a></h3><p><strong>定义</strong></p><ul><li>CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求</li><li>如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作</li><li>CSRF攻击的本质是利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充</li></ul><p><strong>攻击类型</strong></p><ul><li>GET类型的CSRF攻击，比如在网站中的一个img标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交</li><li>POST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li><li>链接类型的CSRF攻击，比如在a标签的href属性里构建一个请求，然后诱导用户去点击</li></ul><p><strong>防御</strong></p><ul><li>进行同源检测：服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤</li><li>使用Token验证：服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证</li><li>对Cookie进行双重验证：服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证</li></ul>`,75),t=[p];function r(i,c,y,F,D,C){return a(),l("div",null,t)}const h=s(e,[["render",r]]);export{u as __pageData,h as default};
