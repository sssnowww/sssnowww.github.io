import{_ as a,o as l,c as i,R as e}from"./chunks/framework.ac544104.js";const n="/tcp_ip_1.png",s="/tcp_1.png",t="/tcp_2.png",r="/udp_tcp_1.png",p="/udp_tcp_2.png",o="/udp_tcp_3.png",c="/url.png",A=JSON.parse('{"title":"计算机网络","description":"","frontmatter":{},"headers":[],"relativePath":"articles/计算机网络.md","lastUpdated":1681047375000}'),h={name:"articles/计算机网络.md"},T=e('<h1 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h1><h2 id="http-建立流程" tabindex="-1">HTTP 建立流程 <a class="header-anchor" href="#http-建立流程" aria-label="Permalink to &quot;HTTP 建立流程&quot;">​</a></h2><p>第1步：TCP通过三次握手建立双方连接；<br> 第2步：客户端通过发送请求报文及请求数据给服务端；<br> 第3步：服务端返回响应报文及响应数据给客户端；<br> 第4步：TCP通过四次挥手进行断开连接。</p><h2 id="tcp-ip协议" tabindex="-1">TCP/IP协议 <a class="header-anchor" href="#tcp-ip协议" aria-label="Permalink to &quot;TCP/IP协议&quot;">​</a></h2><p><img src="'+n+'" alt="An image"></p><h2 id="tcp连接" tabindex="-1">TCP连接 <a class="header-anchor" href="#tcp连接" aria-label="Permalink to &quot;TCP连接&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><ul><li>第1次握手：客户端通过标志位发送SYN = j给服务端，表明客户端想要建立连接，并进入SYN_SEND状态，等待服务器确认。</li><li>第2次握手：服务端收到SYN标志后返回ACK = (j+1)应答标志给客户端，同时自己也发送一个SYN包（syn=k），表明可以建立连接，此时服务器进入SYN_RECV状态。</li><li>第3次握手：客户端收到服务端SYN+ACK应答标志后回传ACK=(k+1)标志给服务端，说明自己已经收到了ACK标志，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 <img src="'+s+'" alt="An image"></li></ul><p>为什么不是两次握手？</p><ul><li>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</li><li>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</li></ul><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><ul><li>第1次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第2次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li><li>第3次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li><li>第4次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态 <img src="'+t+'" alt="An image"></li></ul><p>四次挥手原因？</p><ul><li>服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手</li></ul><h2 id="tcp和udp的区别" tabindex="-1">TCP和UDP的区别 <a class="header-anchor" href="#tcp和udp的区别" aria-label="Permalink to &quot;TCP和UDP的区别&quot;">​</a></h2><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h3><p>UDP：用户数据包协议，是一个简单的面向数据报的通信协议。</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h3><p>TCP：传输控制协议，是一种可靠、面向字节流的通信协议。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>UDP与TCP都位于传输层。 <img src="'+r+'" alt="An image"> 两者区别如下表所示： <img src="'+p+'" alt="An image"></p><ul><li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li><li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li><li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li><li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p><img src="'+o+`" alt="An image"></p><h2 id="http1-0-1-1-2-0的区别" tabindex="-1">HTTP1.0/1.1/2.0的区别 <a class="header-anchor" href="#http1-0-1-1-2-0的区别" aria-label="Permalink to &quot;HTTP1.0/1.1/2.0的区别&quot;">​</a></h2><h3 id="http1-0" tabindex="-1">HTTP1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;HTTP1.0&quot;">​</a></h3><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接。</li></ul><h3 id="http1-1" tabindex="-1">HTTP1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;HTTP1.1&quot;">​</a></h3><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><h3 id="http2-0" tabindex="-1">HTTP2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;HTTP2.0&quot;">​</a></h3><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="http和https的区别" tabindex="-1">HTTP和HTTPS的区别 <a class="header-anchor" href="#http和https的区别" aria-label="Permalink to &quot;HTTP和HTTPS的区别&quot;">​</a></h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li><li>HTTP和HTTPS使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS由于需要设计加密以及多次握手，性能方面不如HTTP</li><li>HTTPS需要SSL，SSL证书需要钱，功能越强大的证书费用越高</li></ul><h2 id="http状态码的含义" tabindex="-1">HTTP状态码的含义 <a class="header-anchor" href="#http状态码的含义" aria-label="Permalink to &quot;HTTP状态码的含义&quot;">​</a></h2><ul><li>304 表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>301 永久性重定向，表示资源已被分配了新的 URL</li><li>401 表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 表示对请求资源的访问被服务器拒绝</li></ul><h2 id="get和post区别" tabindex="-1">GET和POST区别 <a class="header-anchor" href="#get和post区别" aria-label="Permalink to &quot;GET和POST区别&quot;">​</a></h2><h3 id="get" tabindex="-1">GET <a class="header-anchor" href="#get" aria-label="Permalink to &quot;GET&quot;">​</a></h3><p>GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。</p><h3 id="post" tabindex="-1">POST <a class="header-anchor" href="#post" aria-label="Permalink to &quot;POST&quot;">​</a></h3><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。</p><h3 id="区别-1" tabindex="-1">区别 <a class="header-anchor" href="#区别-1" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>本质上都是TCP链接，并无差别，但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别。</p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p><strong>参数位置</strong></p><ul><li>不携带参数时，最大区别为第一行方法名不同。</li></ul><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST /uri HTTP/1.1 \\r\\n</span></span>
<span class="line"><span style="color:#A6ACCD;">GET /uri HTTP/1.1 \\r\\n</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>携带参数时，GET请求是放在url中，POST则放在body中</li></ul><p>GET</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: localhost</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>POST</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST /index.html HTTP/1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: localhost</span></span>
<span class="line"><span style="color:#A6ACCD;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">name=qiming.c&amp;age=22</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>参数长度</strong></p><p><strong>安全</strong></p><ul><li>POST比GET安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，只有使用HTTPS才能加密安全。 <strong>数据包</strong></li><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）</li><li>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</li></ul><h2 id="地址栏输入-url-敲下回车后发生了什么" tabindex="-1">地址栏输入 URL 敲下回车后发生了什么? <a class="header-anchor" href="#地址栏输入-url-敲下回车后发生了什么" aria-label="Permalink to &quot;地址栏输入 URL 敲下回车后发生了什么?&quot;">​</a></h2><ul><li>URL解析</li><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>响应请求</li><li>页面渲染</li></ul><p><strong>页面渲染的过程：</strong></p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上 <img src="`+c+'" alt="An image"></li></ul><h2 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h2><ul><li>多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用</li><li>http 重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点：只有第一次有效果，后续操作维持在该服务器</li><li>dns 负载均衡：解析域名时，访问多个 ip 服务器中的一个（可监控性较弱），原因 - 避免 DOM 渲染的冲突</li><li>反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到服务器群的数量</li></ul>',60),d=[T];function u(P,m,b,C,S,_){return l(),i("div",null,d)}const q=a(h,[["render",u]]);export{A as __pageData,q as default};
