import{_ as a,o as s,c as e,R as l}from"./chunks/framework.ac544104.js";const g=JSON.parse('{"title":"tass-ui组件库","description":"","frontmatter":{},"headers":[],"relativePath":"articles/tass-ui.md","lastUpdated":1681047375000}'),n={name:"articles/tass-ui.md"},r=l(`<h1 id="tass-ui组件库" tabindex="-1">tass-ui组件库 <a class="header-anchor" href="#tass-ui组件库" aria-label="Permalink to &quot;tass-ui组件库&quot;">​</a></h1><h2 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to &quot;monorepo&quot;">​</a></h2><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h3><p>一个仓库内包含多个开发项目（模块，包）。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>存储所有项目代码的单独位置，团队中的每个人都可以访问。</li><li>易于重用和共享代码，与团队合作。</li><li>很容易理解你的变更对整个项目的影响。</li><li>代码重构和代码大变更的最佳选择。</li><li>团队成员可以获得整个项目的总体视图。</li><li>易于管理依赖关系。</li></ul><h2 id="上传upload" tabindex="-1">上传Upload <a class="header-anchor" href="#上传upload" aria-label="Permalink to &quot;上传Upload&quot;">​</a></h2><p><a href="https://juejin.cn/post/7135121438322720799" target="_blank" rel="noreferrer">https://juejin.cn/post/7135121438322720799</a></p><h3 id="设计思路" tabindex="-1">设计思路 <a class="header-anchor" href="#设计思路" aria-label="Permalink to &quot;设计思路&quot;">​</a></h3><ul><li>使用<code>&lt;tass-button&gt;</code>组件实现点击上传的按钮，当按钮被点击时，会调用beginUpload()方法，该方法使用input标签的click()方法触发文件选择框。选择完毕后我们可以在原生input的change事件中获取到我们选中的文件。</li><li>使用<code>&lt;div class=&quot;drop-upload&quot;&gt;</code>元素实现拖拽上传功能，当用户将文件拖到这个区域时，会动态改变样式（通过设置isDrag和style），并阻止默认事件。当文件被放置时，会调用handleDrop()方法，该方法将上传的文件添加到文件列表中，并通过emits()方法向父组件发射dropUpload事件。</li><li>使用<code>&lt;div class=&quot;file&quot;&gt;</code>元素来显示已选文件列表，遍历fileList数组，将每个文件的名称和删除按钮显示出来。当删除按钮被点击时，会调用deleteUpload()方法，该方法从文件列表中删除相应的文件，同时通过emits()方法向父组件发射deleteUpload事件。</li><li>在submitUpload()方法中，获取到上传的文件对象，将其添加到fileList数组中，同时通过emits()方法向父组件发射changeUpload事件。</li><li>使用Vue3中提供的setup()函数来编写组件逻辑，通过defineProps()和defineEmits()定义组件的props和events。在onMounted()生命周期钩子中，使用addEventListener()方法添加事件监听器，实现拖拽上传功能。最后，将组件的状态和方法通过export default导出以供父组件使用。</li></ul><h3 id="实现拖拽" tabindex="-1">实现拖拽 <a class="header-anchor" href="#实现拖拽" aria-label="Permalink to &quot;实现拖拽&quot;">​</a></h3><p>实现拖拽上传借助的是drop事件，在组件生命周期onMounted中获取到拖拽区域的DOM，然后监听它的drop事件。</p><p>首先给拖拽区域一个ref属性。</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- &lt;div class=&quot;drop-upload&quot; v-if=&quot;props.drop&quot; ref=&quot;drag&quot; :style=&quot;isDrag?style:&#39;&#39;&quot;&gt; --&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后在组件创建完成后进行事件监听。</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">onMounted(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    drag.value?.addEventListener(&#39;drop&#39;, handleDrop)</span></span>
<span class="line"><span style="color:#A6ACCD;">    drag.value?.addEventListener(&#39;dragleave&#39;, (e) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    isDrag.value=false</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">    drag.value?.addEventListener(&#39;dragenter&#39;, (e) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    e.preventDefault()</span></span>
<span class="line"><span style="color:#A6ACCD;">    isDrag.value=true</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">    drag.value?.addEventListener(&#39;dragover&#39;, (e) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    e.preventDefault()</span></span>
<span class="line"><span style="color:#A6ACCD;">    isDrag.value=true</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这里需要阻止dragover的默认事件，不然drop是不生效的。</p><p>最后再加两个事件dragenter和dragleave来判断文件是否拖到这个区域从而展示不同样式。</p><p>注：HTML5新增了一个api，给一个元素设置 draggable = true 属性时,该元素就会支持拖拽。</p><h2 id="progress进度条" tabindex="-1">progress进度条 <a class="header-anchor" href="#progress进度条" aria-label="Permalink to &quot;progress进度条&quot;">​</a></h2><h3 id="设计思路-1" tabindex="-1">设计思路 <a class="header-anchor" href="#设计思路-1" aria-label="Permalink to &quot;设计思路&quot;">​</a></h3><ul><li>使用<code>&lt;div class=&quot;tas-progress&quot;&gt;</code>元素实现线性进度条，在组件中使用props对象接收父组件传来的数据（例如：颜色、百分比等）。根据不同的类型和状态，动态设置进度条的样式和内容。</li><li>当进度条类型为“in”时，显示一条粗线条，用另一条细线条表示当前进度百分比。当进度条为100%时，显示文字“满”。</li><li>当进度条类型为“out”时，显示圆形进度条。在圆形进度条中，我们使用SVG元素画出了两个环：灰色环代表总进度，实际进度由颜色环表示。通过计算当前进度百分比，动态改变颜色环的stroke-dasharray属性，从而实现动画效果。同时，根据不同的状态，可以在进度条上显示不同的图标或文本。</li><li>使用Vue3中提供的setup()函数来编写组件逻辑，通过defineProps()定义组件的props。使用toRefs()将props对象转换为响应式对象，并使用ref()创建一个progressValue变量，该变量表示当前进度对应的值。在watch()函数中监听percent属性的改变，实时更新progressValue的值。最后，将组件状态和方法通过export default导出以供父组件使用。</li></ul><h3 id="canvas和svg的区别" tabindex="-1">canvas和svg的区别 <a class="header-anchor" href="#canvas和svg的区别" aria-label="Permalink to &quot;canvas和svg的区别&quot;">​</a></h3><ul><li>svg是一种矢量图，而canvas依赖于分辨率，所以svg放大不会失真，但canvas绘制的图形会失真。</li><li>svg支持事件处理器，而canvas不支持事件处理器。</li></ul><h2 id="todo-list" tabindex="-1">Todo-List <a class="header-anchor" href="#todo-list" aria-label="Permalink to &quot;Todo-List&quot;">​</a></h2><h3 id="组件化编码流程" tabindex="-1">组件化编码流程 <a class="header-anchor" href="#组件化编码流程" aria-label="Permalink to &quot;组件化编码流程&quot;">​</a></h3><ol><li>拆分静态组件：组件要按照功能点拆分，命名不要与<code>html</code>元素冲突。</li><li>实现动态组件：考虑好数据的存放位置，数据是一个组件在用还是一些组件在用 <ul><li>一个组件在用：放在组件自身即可</li><li>一些组件在用：放在他们共同的父组件上（状态提升）</li></ul></li><li>实现交互：从绑定事件开始</li></ol>`,27),t=[r];function o(i,p,d,c,u,h){return s(),e("div",null,t)}const m=a(n,[["render",o]]);export{g as __pageData,m as default};
