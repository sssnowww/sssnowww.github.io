import{_ as e,c as i,o as a,N as l}from"./chunks/framework.1e6a71f2.js";const t="/shengmingzhouqi.png",r="/zujiantongxin.png",f=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Vue.md"}'),o={name:"articles/Vue.md"},u=l('<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="vue核心特性" tabindex="-1">Vue核心特性 <a class="header-anchor" href="#vue核心特性" aria-label="Permalink to &quot;Vue核心特性&quot;">​</a></h2><h3 id="数据驱动-mvvm" tabindex="-1">数据驱动（MVVM） <a class="header-anchor" href="#数据驱动-mvvm" aria-label="Permalink to &quot;数据驱动（MVVM）&quot;">​</a></h3><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li></ul><h3 id="组件化" tabindex="-1">组件化 <a class="header-anchor" href="#组件化" aria-label="Permalink to &quot;组件化&quot;">​</a></h3><ul><li>降低整个系统的耦合度</li><li>调试方便</li><li>提高可维护性</li></ul><h3 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h3><p>常用指令：</p><ul><li>条件渲染指令v-if</li><li>列表渲染指令v-for</li><li>属性绑定指令v-bind</li><li>事件绑定指令v-on</li><li>双向数据绑定指令v-model</li></ul><h2 id="vue相较于原生js的优点" tabindex="-1">Vue相较于原生JS的优点 <a class="header-anchor" href="#vue相较于原生js的优点" aria-label="Permalink to &quot;Vue相较于原生JS的优点&quot;">​</a></h2><ul><li>1.数据的自动绑定</li><li>2.页面参数传递和页面状态管理</li><li>3.模块化开发、无刷新保留场景参数更新</li><li>4.代码的可阅读性（模块化开发带来的）</li><li>5.基于强大的nodejs，拥有npm包管理器，可以很好滴管理包的版本</li><li>6.各子组件样式不冲突</li><li>7.视图,数据,结构分离</li><li>8.虚拟dom</li><li>9.各种指令;过滤器</li></ul><h2 id="vue和react对比" tabindex="-1">Vue和React对比 <a class="header-anchor" href="#vue和react对比" aria-label="Permalink to &quot;Vue和React对比&quot;">​</a></h2><h3 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：Vue的weex、React的React native</li><li>都有自己的构建工具：Vue的vue-cli、React的Create React App</li></ul><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据</li><li>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</li></ul><h2 id="v-if和v-show" tabindex="-1">v-if和v-show <a class="header-anchor" href="#v-if和v-show" aria-label="Permalink to &quot;v-if和v-show&quot;">​</a></h2><h3 id="相同点-1" tabindex="-1">相同点 <a class="header-anchor" href="#相同点-1" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ul><li>都能控制DOM元素在页面的显示</li></ul><h3 id="区别-1" tabindex="-1">区别 <a class="header-anchor" href="#区别-1" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>v-if是动态添加，当值为false时，是完全移除该元素，即DOM树中不存在该元素</li><li>v-show仅是隐藏/显示，值为false时，该元素依旧存在于DOM树中</li><li>v-if比v-show开销更大（直接操作DOM节点增加与删除）</li><li>如果需要非常频繁地切换，则使用 v-show 较好</li><li>如果在运行时条件很少改变，则使用 v-if 较好</li></ul><h2 id="vue实例挂载的过程" tabindex="-1">Vue实例挂载的过程 <a class="header-anchor" href="#vue实例挂载的过程" aria-label="Permalink to &quot;Vue实例挂载的过程&quot;">​</a></h2><ul><li>new Vue的时候调用会调用_init方法 <ul><li>定义 $set、$get 、$delete、$watch 等方法</li><li>定义 $on、$off、$emit、$off等事件</li><li>定义 _update、$forceUpdate、$destroy生命周期</li></ul></li><li>调用$mount进行页面的挂载</li><li>挂载的时候主要是通过mountComponent方法</li><li>定义updateComponent更新函数</li><li>执行render生成虚拟DOM</li><li>_update将虚拟DOM生成真实DOM结构，并且渲染到页面中</li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p><img src="'+t+'" alt="An image"></p><h2 id="组件间通信" tabindex="-1">组件间通信 <a class="header-anchor" href="#组件间通信" aria-label="Permalink to &quot;组件间通信&quot;">​</a></h2><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h3><p><img src="'+r+'" alt="An image"></p><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><p><strong>props传递数据</strong></p><ul><li>适用场景：父组件传递数据给子组件</li><li>子组件设置props属性，定义接收父组件传递过来的参数</li><li>父组件在使用子组件标签中通过字面量来传递值</li></ul><p><strong>$emit触发自定义事件</strong></p><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul><p><strong>ref</strong></p><ul><li>父组件在使用子组件的时候设置ref</li><li>父组件通过设置子组件ref来获取数据</li></ul><p><strong>EventBus</strong></p><ul><li>使用场景：兄弟组件传值</li><li>创建一个中央事件总线EventBus</li><li>兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li><li>另一个兄弟组件通过$on监听自定义事件</li></ul><h2 id="mixin" tabindex="-1">mixin <a class="header-anchor" href="#mixin" aria-label="Permalink to &quot;mixin&quot;">​</a></h2><ul><li>替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数</li><li>合并型策略是data, 通过set方法进行合并和重新赋值</li><li>队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行</li><li>叠加型有component、directives、filters，通过原型链进行层层的叠加</li></ul><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><ul><li>它是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。</li><li>在Javascript对象中，虚拟DOM表现为一个Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性。</li><li>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应。</li></ul><h3 id="为什么要用虚拟dom" tabindex="-1">为什么要用虚拟DOM <a class="header-anchor" href="#为什么要用虚拟dom" aria-label="Permalink to &quot;为什么要用虚拟DOM&quot;">​</a></h3><p>操作DOM的代价是昂贵的，频繁操作会出现页面卡顿，影响用户的体验。</p><h3 id="如何实现虚拟dom" tabindex="-1">如何实现虚拟DOM <a class="header-anchor" href="#如何实现虚拟dom" aria-label="Permalink to &quot;如何实现虚拟DOM&quot;">​</a></h3><p>createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构。</p><h2 id="vue3-0与vue2-0的区别" tabindex="-1">Vue3.0与Vue2.0的区别 <a class="header-anchor" href="#vue3-0与vue2-0的区别" aria-label="Permalink to &quot;Vue3.0与Vue2.0的区别&quot;">​</a></h2><h3 id="双向数据绑定原理不同" tabindex="-1">双向数据绑定原理不同 <a class="header-anchor" href="#双向数据绑定原理不同" aria-label="Permalink to &quot;双向数据绑定原理不同&quot;">​</a></h3><ul><li>vue2-ES5的API-Object.definePropert()对数据进行劫持，结合发布订阅模式的方式来实现的。通过Object.defineProperty()方法来劫持（监听）各属性的getter、setter，并在当监听的属性发生变动时通知订阅者是否需要更新，若更新就会执行对应的更新函数</li><li>vue3-ES6的Proxy API对数据代理，优势：1、defineProperty只能监听某个属性，不能对全对象监听；2、可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)；3、可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化。</li></ul><h3 id="是否支持碎片" tabindex="-1">是否支持碎片 <a class="header-anchor" href="#是否支持碎片" aria-label="Permalink to &quot;是否支持碎片&quot;">​</a></h3><p>vue3支持，就是说可以拥有多个根节点。</p><h3 id="api类型不同" tabindex="-1">API类型不同 <a class="header-anchor" href="#api类型不同" aria-label="Permalink to &quot;API类型不同&quot;">​</a></h3><ul><li>vue2-选项类型API在代码里分割了不同的属性</li><li>vue3-合成型API能让我们使用方法来分割</li></ul><h3 id="定义数据变量和方法不同" tabindex="-1">定义数据变量和方法不同 <a class="header-anchor" href="#定义数据变量和方法不同" aria-label="Permalink to &quot;定义数据变量和方法不同&quot;">​</a></h3><ul><li>vue2-数据变量：data(){}，方法：methods:{}；</li><li>vue3-使用一个新的setup()方法，此方法在组件初始化构造的时候触发，使用以下三个步骤建立反应性数据：1、从vue引入reactive；2、使用reactive（）方法来声明数据为响应型数据；3、使用setup()方法来返回响应性数据，从而template可以获取这些响应型数据</li></ul><h3 id="生命周期钩子函数不同" tabindex="-1">生命周期钩子函数不同 <a class="header-anchor" href="#生命周期钩子函数不同" aria-label="Permalink to &quot;生命周期钩子函数不同&quot;">​</a></h3><p>vue2：</p><ul><li>beforeCreate 组件创建之前</li><li>created 组件创建之后</li><li>beforeMount 组价挂载到页面之前执行</li><li>mounted 组件挂载到页面之后执行</li><li>beforeUpdate 组件更新之前</li><li>updated 组件更新之后</li></ul><p>vue3：</p><ul><li>setup 开始创建组件</li><li>onBeforeMount 组价挂载到页面之前执行</li><li>onMounted 组件挂载到页面之后执行</li><li>onBeforeUpdate 组件更新之前</li><li>onUpdated 组件更新之后</li></ul><h3 id="父子传参不同" tabindex="-1">父子传参不同 <a class="header-anchor" href="#父子传参不同" aria-label="Permalink to &quot;父子传参不同&quot;">​</a></h3><ul><li>vue2：父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象。</li><li>vue3：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。</li></ul><h3 id="指令与插槽不同" tabindex="-1">指令与插槽不同 <a class="header-anchor" href="#指令与插槽不同" aria-label="Permalink to &quot;指令与插槽不同&quot;">​</a></h3><ul><li>vue2：使用pototype(原型)的形式去进行操作，引入的是构造函数。</li><li>vue3：使用结构的形式进行操作，引入的是工厂函数；vue3中app组件中可以没有根标签。</li></ul><h3 id="main-js文件不同" tabindex="-1">main.js文件不同 <a class="header-anchor" href="#main-js文件不同" aria-label="Permalink to &quot;main.js文件不同&quot;">​</a></h3><h2 id="vue3响应式原理" tabindex="-1">Vue3响应式原理 <a class="header-anchor" href="#vue3响应式原理" aria-label="Permalink to &quot;Vue3响应式原理&quot;">​</a></h2><p>proxy：ES6新特性，Proxy对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。为什么用proxy代替defineProperty？</p><h3 id="object-defineproperty" tabindex="-1">Object.defineProperty() <a class="header-anchor" href="#object-defineproperty" aria-label="Permalink to &quot;Object.defineProperty()&quot;">​</a></h3><ul><li>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li><li>为什么能实现响应式？-通过get和set属性。</li><li>缺点： <ul><li>检测不到对象属性的添加和删除</li><li>数组API方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ul></li></ul><h3 id="proxy" tabindex="-1">proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;proxy&quot;">​</a></h3><ul><li>定义：用于定义基本操作的自定义行为。</li><li>用法：Proxy为构造函数，用来生成Proxy实例。</li><li>使用场景： <ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul></li><li>proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就可以完全代理所有属性了。</li></ul><h2 id="vue-router原理" tabindex="-1">vue-router原理 <a class="header-anchor" href="#vue-router原理" aria-label="Permalink to &quot;vue-router原理&quot;">​</a></h2><ul><li>vue-router是一个基于vue的路由管理器，它可以让我们用vue构建单页应用（SPA），实现不同的url对应不同的组件。</li><li>vue-router有两种模式：hash模式和history模式。hash模式是利用浏览器的hashchange事件来监听url的变化，并根据hash值来匹配路由；history模式是利用HTML5的history API来操作浏览器历史记录，并根据路径名来匹配路由。</li><li>vue-router主要包括两部分：一部分是浏览器地址的监听，将url改变监听到并存入vueRouter类中；另一部分是将vueRouter与vue连接起来，这部分主要是靠vue的插件机制实现的。</li><li>vue-router提供了一些组件和指令来方便我们使用路由功能，例如router-link组件用来生成链接，router-view组件用来渲染匹配到的组件，v-bind:to指令用来绑定目标地址等。</li><li>vue-router还支持一些高级功能，例如路由懒加载、动态路由、嵌套路由、导航守卫等。</li></ul><h3 id="路由的hash模式和history模式区别" tabindex="-1">路由的hash模式和history模式区别 <a class="header-anchor" href="#路由的hash模式和history模式区别" aria-label="Permalink to &quot;路由的hash模式和history模式区别&quot;">​</a></h3><ul><li>二者都是利用浏览器的两种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location对象hash值变化事件来实现</li><li>history的url没有&#39;#&#39;号，hash反之</li><li>相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发，history需要后端配合，如果后端不配合刷新页面会出现404，hash不需要</li></ul><h2 id="tree-shaking" tabindex="-1">tree shaking <a class="header-anchor" href="#tree-shaking" aria-label="Permalink to &quot;tree shaking&quot;">​</a></h2>',76),h=[u];function n(s,d,c,p,m,v){return a(),i("div",null,h)}const q=e(o,[["render",n]]);export{f as __pageData,q as default};
